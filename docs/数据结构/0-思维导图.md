---
title: 思维导图
# hidden: true

# 打开评论
comment: true
date: 2023-11-23
hidden: true
outline: [2, 3]
---

# 数据结构

## 第一章 绪论

### 1.1 数据结构的概念
#### 什么是数据结构

- 描述非数值计算问题的数学模型

#### 数据结构的意义

- 算法 + 数据结构 = 程序

- 程序设计的本质是对实际问题选择一种好的数据结构，并设计一个好的算法

- 数据结构是介于数学、计算机硬件和软件三者之间的一门核心课程

### 1.2 基本概念和术语
#### 数据与数据元素

- 数据（Data）是对客观事物的符号表示，它能被计算机识别、存储和加工处理

- 数据元素（Data Element）是数据的基本单位，又称元素、结点、顶点、记录
  - 一个数据元素又可以由多个数据项（Data Item）组成
  - 数据项是最小标识单位

#### 数据的逻辑结构

- 概念
  - 数据的逻辑结构是从逻辑关系上描述数据，不涉及数据在计算机中的存储，是独立于计算机的

- 集合
  - 任何两个元素之间都没有逻辑关系，每个元素都是孤立的

- 线性结构
  - 结构中的元素之间存在一对一的关系，即所谓的线性关系。四级考试成绩表就是一个线性结构

- 树形结构
  - 结构中的数据元素之间存在一对多的关系，在这种结构中，元素之间的逻辑关系通常称作双亲与子女关系。例如，家谱、行政组织结构等都可用树形结构来表示

- 图状结构
  - 结构中的元素之间存在多对多的关系。也就是说，元素间的逻辑关系可以是任意的。在这种结构中，元素间的逻辑关系也称作邻接关系。

- 逻辑结构分类
  - 通常将集合、树形结构、图状结构归纳为非线性结构。因此，数据的逻辑结构可分为两大类，即线性结构和非线性结构
#### 数据的存储结构

- 概念
  - 数据的存储结构是指数据在计算机内的表示方法，是逻辑结构的具体实现

- 顺序存储
  - 将数据元素依次存储于一组地址连续的存储单元中，元素间的逻辑关系由存储单元的位置直接体现，由此得到的存储表示称为顺序存储结构（Sequential Storage Structure）。
  - 高级语言中，常用一维数组来实现顺序存储结构。
  - 该方法主要用于线性结构。非线性结构也可通过某种线性化的处理，实现顺序存储。

- 链接存储
  - 将数据元素存储在一组任意的存储单元中，用附加的指针域表示元素之间的逻辑关系，由此得到的存储表示称为链接存储（Linked Storage Structure）。
  - 使用这种存储结构时，往往把一个数据元素及附加的指针一起称作一个结点。
  - 高级语言中，常用指针变量实现链接存储。

- 索引存储
  - 该方法的特点是在存储数据元素的同时，还可以建立附加的索引表。
  - 索引表中每一项称为索引项。索引项的一般形式是：（关键字，地址）。
  - 关键字是指能唯一标识数据元素的数据项。
  - 若每个数据元素在索引表中均有一个索引项，则该索引表称为稠密索引（Dense Index）。
  - 若一个索引项对应一组数据元素，则该索引表称为稀疏索引（Sparse Index）。

- 散列存储
  - 该方法是依据数据元素的关键字，用一个事先设计好的函数计算出该数据元素的存储地址，然后把它存入该地址中。
  - 这种函数称为散列函数，由散列函数计算出的地址称为散列地址。

- 存储结构的描述
  - 存储结构的描述与程序设计语言有关。用机器语言描述，则存储结构是数据元素在存储器中的物理位置；用高级语言描述，则不必涉及计算机的内存地址，可用类型说明来描述存储结构。
#### 数据运算

- 概念
  - 数据运算是对数据施加的操作。每种逻辑结构都有一个基本运算的集合

- 因为这些运算是在逻辑结构上施加的操作，因此它们同逻辑结构一样也是抽象的，只规定“做什么”，无须考虑“如何做”。只有确定存储结构后，才能考虑“如何做”。简言之，运算在逻辑结构上定义，在存储结构上实现。

- 数据结构包含逻辑结构、存储结构和运算三方面的内容
#### 数据类型
- 概念
  - 数据类型（Date Type）是一个值的集合和在这个集合上定义的一组操作的总称

- 原子类型
  - 其值不可分解
  - 如C++的基本类型（整型、字符型、实型、枚举型）、指针类型和空类型。

- 结构类型
  - 其值可分解成若干成分（或称分量）
  - 如C++的数组类型、结构类型等。结构类型的成分可以是原子类型，也可以是某种结构类型。可以把数据类型看作程序设计语言已实现的数据结构。
- 引入的目的
  - 从硬件角度考虑，是作为解释计算机内存中信息含义的一种手段
  - 对用户来说，实现了信息的隐蔽，即将一切用户不必了解的细节都封装在类型中

#### 抽象数据类型
- 概念
  - 抽象数据类型（Abstract Data Type, ADT）是指一个数学模型，以及定义在该模型上的一组操作

- 抽象数据类型和数据类型实质上是一个概念

- 但在另一方面，抽象数据类型的范畴更广。
  - 它不再局限于前述各处理器中已定义并实现的数据类型
  - 还包括用户在设计软件系统时自己定义的数据类型

- 抽象数据结构的特征
  - 是使用与实现相分离，实行封装的信息隐蔽
  - 在抽象数据类型设计时，把类型的定义与其实现分离开来。

### 1.3 算法和算法分析


## 第二章 C++程序设计基础知识

### 2.1 C++的基本操作

### 2.2 类与对象

## 第三章 线性表

### 3.1 线性表的定义及其运算
#### 3.1.1 线性表的定义
- 概念
  - 线性表是具有相同数据类型的n(n≥0)个数据元素的有限序列，通常记为：（a1, a2, …, ai-1, ai, ai+1,…, an）。其中，n为数据元素个数，称为表长。当n=0时称为空表。

#### 3.1.2 线性表的运算
- （1）线性表初始化：void Initiate()
  - 初始条件：线性表不存在。
  - 操作结果：构造一个空的线性表。

- （2）求线性表的长度：int Length()
  - 初始条件：线性表已存在。
  - 操作结果：返回线性表所含数据元素的个数。

- （3）取表元：DataType Get(int i)
  - 初始条件：表存在且1≤i≤Length()。
  - 操作结果：返回线性表的第i个数据元素的值。

- （4）按值查找：int Locate(DataType x)
  - 初始条件：线性表已存在，x是给定的一个数据元素。
  - 操作结果：在线性表中查找值为x的数据元素，返回首次出现的值为x的那个数据元素的序号，称为查找成功；如果未找到值为x的数据元素，返回0表示查找失败。

- （5）插入操作：int Insert(DataType x, int i)
  - 初始条件：线性表已存在。
  - 操作结果：在线性表的第i个位置上插入一个值为x的新元素，使原序号为i,i+1, …,n的数据元素的序号变为i+1,i+2, …,n+1，插入后表长=原表长+1，返回1表示插入成功；若线性表L中数据元素个数少于i-1个，则返回0表示插入失败。

- （6）删除操作：int Deleted(int i)
  - 初始条件：线性表已存在。
  - 操作结果：在线性表L中删除序号为i的数据元素，删除后使序号为i+1, i+2, …, n的元素变为序号i,i+1, …, n-1，新表长=原表长-1，返回1；若线性表中数据元素个数少于i，则返回0表示删除失败。

#### 3.1.3 线性表的抽象数据结构描述
```cpp
ADT  LinearList is
Data:
一个线性表L定义为L=(a1, a2, …, an)，当L=()时定义为一个空表。
Operation:
    void Initiate()                //线性表初始化
    int Length()                   //求线性表的长度
    DataType Get(int i)            //取表元
    int Locate(DataType x)         //按值查找
    int Insert(DataType x, int i)   //插入操作
    int Deleted(int i)             //删除操作
END  LinearList
```

### 3.2 线性表的顺序存储结构
- 3.2.1顺序表结构
  - 存储地址
    - Loc(ai)=Loc(a1)+(i-1)*d1≤i≤n
  - 数据结构定义
    - ```cpp
      #define MAXSIZE 100
      typedef int DataType;
      class SequenList
      {
          public:
            void Initiate();
            int Length();
            int Insert(DataType x, int i);
            int Deleted(int i);
            int Locate(DataType x);
            DataType Get(int i);
          private:
            DataType data[MAXSIZE];
            int len;
      };
      ```


- 3.2.2 顺序表运算
  - 顺序表的初始化
    - ```cpp
      void SequenList::Initiate()
      {
          len=0;
      }
      ```
  - 插入运算
    - ```cpp
      int SequenList::Insert(DataType x, int i)
      {
          //在线性表的第i个数据元素之前插入一个新的数据元素x
          int j;
          if(len>=MAXSIZE)
          {
            cout<<"overflow! "<<endl;             //数据溢出
            return 0;
          }
          else if((i<1)|| (i>len+1))              //如果插入位置不合法
          {
            cout <<"position is not correct! "<<endl;
            return 0;
          }
          else
          {
            for(j=len; j>=i; j--)
                data[j]=data[j-1];               //元素后移
            data[i-1]=x;                        //插入元素
            len++;                              //表长度增加1
            return 1;
          }
      }
      ```
  - 删除运算
    - ```cpp
      int SequenList::Deleted(int i)     //删除顺序表的第i个数据元素
      {
          int j;
          if((i<1)|| (i>len))            //若删除位置不合法
          {
            cout<<"position is not correct! "<<endl;
            return 0;
          }
          else
          {
            for(j=i; j<len; j++)
                data[j-1]=data[j];       //元素前移
            len--;                      //表长度减1
            return 1;
          }
      }
      ```
  - 按值查找
    - ```cpp
      int SequenList::Locate(DataType x)
      {
          //返回值为x的数据元素的位序值
          int j=0;
          while((j<len)&& (data[j]! =x))j++;
          if(j<len)return j+1;
          else return 0;
      }
      ```
  - 读取第i个值
    - ```cpp
      DataType SequenList::Get(int i)
      {
          if((i<1)|| (i>len))
          {
            cout<<"position is not correct! "<<endl;
            return NULL;
          }
          else return data[i-1];
      }
      ```
  - 取得数据元素个数
    - ```cpp
      int SequenList::Length()
      {
          return len;
      }
      ```

- 3.2.3 顺序表存储空间的动态分配
  - 线性表顺序存储结构
    - 是预先给定大小为MAXSIZE的存储空间
    - 程序在编译阶段就已经知道该类型变量的大小
    - 在程序开始运行前会为它分配好存储空间
    - 因此是一种存储空间的静态分配
  - 动态分配是在定义线性表的存储类型时
    - 不是定义好一个存储空间
    - 而是只定义一个指针，待程序运行后再申请一个用于存放线性表数据元素的存储空间，
    - 并把该存储空间的起始地址赋给这个指针。
  - 访问动态存储分配的线性表中的元素和访问静态存储分配的线性表中的元素的情况完全相同，既可以采用指针方式，也可以采用数组下标方式

### 3.3 线性表的链式存储结构
#### 3.3.1 单链表结构
- 结构定义
  - ```cpp
      typedef int DataType;
      class Item
      {
        public:
          DataType data;
          Item * next;
          Item(){next=NULL; }
      };
      class Link
      { public:
          Item *head;                        //链表头指针
          Link(){head=NULL; }                 //构造函数
          ~Link(){DeleteAll(); }             //析构函数
          void Initiate();                   //初始化
          void DeleteAll();                 //删除所有结点
          void HeadCreate(int n);           //从头建链表
          void TailCreate(int n);           //从尾建链表
          void HeadCreateWithHead(int n);   //建立带表头的链表(从头)
          void TailCreateWithHead(int n);   //建立带表头的链表(从尾)
          int Length();                     //求链表长度
          Item *Locatex(DataType x);        //查找值为x的数据元素
          Item *Locatei(int i);             //查找第i个元素
          DataType Get(int i);              //取第i个元素值
          bool Insert(DataType x, int i);    //在链表第i个结点之前插入x
          bool Deleted(int i);              //删除链表中第i个结点
          void Print();                     //打印链表
      };
  ```

#### 3.3.2 单链表运算
- 初始化
  - ```cpp
      void Link::Initiate()
      {
          DeleteAll();
          head=NULL;
      }
  ```


- 建立单链表
  - 从表尾到表头（不带有空白结点）
    - ```cpp
      void Link::HeadCreate(int n)
      {
          DeleteAll();
          Item *s, *p;
          int i;
          p=NULL;
          for(i=1; i<=n; i++)
          {
              s=new Item();
              cin>>s->data;
              s->next=p;
              p=s;
          }
          head=p;
      }
    ```
  - 从表头到表尾建立单链表（不带有空白结点）
    - ```cpp
       void Link::TailCreate(int n)
      {
          Item *s, *r, *p;
          int i;
          DeleteAll();
          p=NULL;
          for(i=1; i<=n; i++)
          {
            s=new Item();
            cin>>s->data;
            s->next=NULL;
            if(p==NULL)p=r=s;
            else
            {
                r->next=s;
                r=s;
            }
          }
          head = p;
      }
    ```
  - 从表尾到表头建立单链表（带有空白结点）
    - ```cpp
      void Link::HeadCreateWithHead(int n)
      {
          Item *s, *p;
          int i;
          DeleteAll();
          p=new Item();
          p->next=NULL;
          for(i=1; i<=n; i++)
          {
            s=new Item();
            cin>>s->data;
            s->next=p->next;
            p->next=s;
          }
          head= p;
      }
    ```
  - 从表头到表尾建立单链表（带有空白结点）
    - ```cpp
    void Link::TailCreateWithHead(int n)
    {
        Item ＊s, ＊r, ＊p;
        int i;
        DeleteAll();
        p=new Item();
        p->next=NULL;
        r=p;
        for(i=1; i<=n; i++)
        {
          s=new Item();
          cin>>s->data;
          r->next=s;
          r=s;
        }
        r->next=NULL;
        head= p;
    }
    ```

- 求表长
- 查找操作
- 插入
- 删除
- 打印
- 删除所有结点


#### 3.3.3 循环链表结构


#### 3.3.4 双向链表结构
- 定义
  - ```cpp
      typedef int DataType;
      class DualItem
      {     public:
            DataType data;
            DualItem *next;
            DualItem *prior;
            DualItem(){next=NULL; prior=NULL; }
      };
  ```

### 3.4 线性表和链式表的比较

#### 顺序表

##### 优点
- 方法简单
- 不用为表示结点间的逻辑关系而增加额外的存储开销
- 可以按元素序号随机访问表中结点

##### 缺点



#### 链式表

##### 优点

##### 缺点


### 3.5 算法应用举例


## 第四章 栈和队列
### 4.1 栈
#### 4.1.1 栈的抽象数据类型

#### 4.1.2 顺序栈
- （1）判断栈是否为空
- （2）入栈操作
- （3）出栈操作
- （4）取栈顶元素操作

#### 4.1.3 链栈
- （1）判断栈是否为空
- （2）入栈操作
- （3）出栈操作
- （4）取栈顶元素操作

#### 4.1.4 栈的应用
- “后进先出”

### 4.2 队列

#### 4.2.1 队列的抽象数据类型

#### 4.2.2 顺序队列

#### 4.2.3 链队列
- 判断链队列是否为空
- 进队操作
- 出队操作
- 取队头元素操作

#### 4.2.4 队列的应用

### 4.3 递归

#### 4.3.1 递归算法书写要点及方法

##### 特点

##### 方法

#### 4.3.2 递归过程的调用和返回

## 第五章 串

### 5.1 C++语言的字符和字符串

#### 5.1.1 C++语言的字符和字符串

#### 5.1.2 一个简单的C++函数

### 5.2 串及其基本运算

#### 5.2.1 串的基本概念
- 1.串的定义
  串是由0个或多个任意字符组成的字符序列
- 2.几个术语


#### 5.2.2 串的基本算法
- （1）求串的长度
- （2）串赋值StrAssign(s1, s2)
- （3）链接操作StrConcat(s1, s2, s)或StrConcat(s1, s2)
- （4）求子串SubStr(s, i, len)
- （5）串比较StrCmp(s1, s2)
- （6）子串定位StrIndex(s, t)
- （7）串插入StrInsert(s, i, t)
- （8）串删除StrDelete(s, i, len)
- （9）串替换StrRep(s, t ,r)

### 5.3 串的顺序存储及其基本运算
#### 5.3.1 串的定长顺序存储

#### 5.3.2 顺序串的数据类型定义

#### 5.3.3 定长顺序串的基本运算

- 1.求串长
- 2.串连接
- 3.求子串
- 4.串比较

#### 5.3.4 模式匹配
- 1.简单的模式匹配算法
  - 
- 2.改进后的模式匹配算法
  - KMP

### 5.4 串的链式存储结构
- 结构中的每个数据元素是一个字符
- 串值的存储密度
  - 存储密度=串值所占的存储位/实际分配的存储位

### 5.5 串操作应用

## 第六章 数组和广义表

### 6.1 数组

#### 6.1.1 数组的定义
- 特点
  - （1）数组中的数据元素具有相同的数据类型
  - （2）数组是一种随机存储结构，可以根据给定的一组下标直接访问对应的数组元素
  - （3）一旦建立了数组，则数组中的数据元素个数和元素之间的关系就不再发生变化

#### 6.1.2 数组的内存映像

### 6.2 特殊矩阵的压缩存储
#### 6.2.1 对称矩阵

#### 6.2.2 三角矩阵

#### 6.2.3 稀疏矩阵



### 6.3 广义表

#### 6.3.1 广义表的定义

#### 6.3.2 广义表的存储

#### 6.3.3 广义表基本操作的实现

## 第七章 树和二叉树

### 7.1 树的基本概念

#### 7.1.1 树的定义及其表示

#### 7.1.2 基本术语



### 7.2 二叉树

#### 7.2.1 二叉树的定义

#### 7.2.2 二叉树的性质

#### 7.2.3 二叉树的存储结构

#### 7.2.4 二叉树抽象数据类型

### 7.3 遍历二叉树

#### 7.3.1 先序遍历

#### 7.3.2 中序遍历

#### 7.3.3 后序遍历

#### 7.3.4 按层序遍历二叉树

#### 7.3.5 遍历算法的应用举例

### 7.4 线索二叉树

#### 7.4.1 线索的概念

#### 7.4.2 线索的描述

#### 7.4.3 线索的算法实现

#### 7.4.4 线索二叉树上的运算

### 7.5 树与森林

#### 7.5.1 树的存储结构

#### 7.5.2 树、森林和二叉树的转换

#### 7.5.3 树和森林的遍历

### 7.6 哈夫曼树

#### 7.6.1 基本术语

#### 7.6.2 哈夫曼树的建立

#### 7.6.3 哈夫曼树的应用

## 第八章 图

### 8.1 图的基本概念

#### 8.1.1 图的定义和术语

#### 8.1.2 图的基本操作

### 8.2 图的存储结构

#### 8.2.1 邻接矩阵

#### 8.2.2 邻接表

#### 8.2.3 十字链表

#### 8.2.4 邻接多重表

### 8.3 图的遍历

#### 8.3.1 深度优先搜索

#### 8.3.2 广度优先搜索

#### 8.3.3 应用图的遍历判定图的连通性

#### 8.3.4 图的遍历的其他应用


### 8.4 生成树和最小生成树

#### 8.4.1 生成树及生成森林

#### 8.4.2 最小生成树的概念

#### 8.4.3 构造最小生成树的Prim算法

#### 8.4.4 构造最小生成树的Kruskal算法

### 8.5 最短路径

#### 8.5.1 单源点的最短路径

#### 8.5.2 每对顶点之间的最短路径

### 8.6 有向无环图及其应用

#### 8.6.1 有向无环图的概念

#### 8.6.2 AOV网与拓扑排序

#### 8.6.3 AOE网与关键路径

## 第九章 查找

### 9.1 基本概念

### 9.2 静态查找表

#### 9.2.1 顺序查找

#### 9.2.2 有序表的查找

#### 9.2.3 分块查找

### 9.3 动态查找表I——数表查找

#### 9.3.1 二叉排序树

#### 9.3.2 平衡二叉树（AVL树）

#### 9.3.3 B-树和B+树

### 9.4 动态查找表II——哈希表查找（杂凑法）

#### 9.4.1 常用的哈希方法

#### 9.4.2 处理冲突的方法

#### 9.4.3 哈希表的操作

## 第十章 排序

### 10.1 基本概念

### 10.2 插入排序

#### 10.2.1 直接插入排序

#### 10.2.2 二分插入排序

#### 10.2.3 希尔排序

### 10.3 交换排序

#### 10.3.1 冒泡排序

#### 10.3.2 快速排序

### 10.4 选择排序

#### 10.4.1 简单选择排序

#### 10.4.2 属性选择排序

#### 10.4.3 堆排序

### 10.5 归并排序

### 10.6 分配排序

#### 10.6.1 多关键码排序

#### 10.6.2链式基数排序

### 10.7 各种内排序方法的比较和选择

